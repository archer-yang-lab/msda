predict.msda(obj, x)
obj
obj$x
library(msda)#
source("utilities.R", chdir = TRUE)#
source("predict.msda.R", chdir = TRUE)#
#
## generate data#
n <- 100#
p <- 1000#
s <- 3#
K <- 3#
#
prior <- rep(1/K, K)#
#
rho <- 0.5#
sigma <- matrix(rho, p, p)#
diag(sigma) <- 1#
sigma.eigen <- eigen(sigma)#
sigma.sqrt <- sigma.eigen$vectors %*% diag(sqrt(sigma.eigen$values)) %*% t(sigma.eigen$vectors)#
#
beta <- matrix(0, p, K)#
for (i in 1:K) {#
    beta[1:s, i] <- i#
}#
mu <- sigma %*% beta#
#
set.seed(1)#
y <- runif(n)#
prior.cum <- cumsum(prior)#
for (i in 1:n) {#
    y[i] <- sum(y[i] < prior.cum)#
}#
#
set.seed(1)#
x <- matrix(rnorm(n * p), n, p)#
x <- x %*% sigma.sqrt#
for (i in 1:K) {#
    x[y == i, ] <- sweep(x[y == i, ], 2, mu[, i], "+")#
}#
# msda.prep(x,y)#
pf <- rep(1, p)#
#
system.time(obj <- msda(x = x, y = y, eps = 1e-06, pf = pf, verbose=FALSE, sml = 1e-5))
setwd('/Users/emeryyi/Desktop')
predict(obj, x)
theta<-obj$theta#
  mu<-obj$mu#
  prior<-obj$prior#
  mubar <- sweep(mu[, -1], 1, mu[, 1], "+")/2#
  n <- nrow(x)#
  p<-ncol(x)#
  x.train<-obj$x#
  y.train<-obj$y
nclass <- length(prior)#
  nlambda <- length(theta)#
  pred<-matrix(0,n,nlambda)#
  pred[1]<-which.max(prior)
i=1
for(i in 1:nlambda){#
    nz<-sum(theta[[i]][,1]!=0)#
    if(nz==0){pred[i]<-which.max(prior)}else{#
      xfit<-x.train%*%theta[[i]][,1:(min(nclass-1,nz))]#
      l<-lda(xfit,y.train)#
      pred[,i]<-predict(l,x%*%theta[[i]][,1:(min(nclass-1,nz))])$class}#
  }
nz
nclass-1,nz
nclass
xfit<-x.train%*%theta[[i]][,1:(min(nclass-1,nz))]
setwd('/Users/emeryyi/Dropbox/Research/googleproject/msda/R')
theta[[i]]
